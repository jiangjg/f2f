# HashMap's hash method （扰动函数）

``` java
int h;
return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
```

## 这段代码叫做：“扰动函数”
简单点说是做一次“16位 右位移 异或 混合”。

## 如何判断一个散列值在散列表中的位置？

### 一种常规的解决思路
1. hashcode
取key的hashcode值，int类型的值是32位来表示的。

2.1 取模运算
然而HashMap的初始数组长度不过16位，这时就需要使这个hashcode值与表长做取模运算，以判断所在数组位置。

2.2 取模运算也可以有不同方式
    1. h % (length - 1)
    2. h & (length - 1)

2.3 “h & (length - 1)”这种写法的原理
length的值为16，那么减1为15。二进制表示就是*00001111。那么与h进行与操作的时候，意思就是取h中低四位的值（这样也就算出了数组下标）。

```
    10001100 00011000 00001100 00000110
&
    00000000 00000000 00000000 00001111
---------------------------------------
    00000000 00000000 00000000 00000110
```

3. 问题来了
以上算法，首先，hashcode的值未必松散；其次，只取hashcode的低位会导致碰撞严重；如果如果hashcode的算法不好，分布上成等差数列，就会导致低位呈规律性重复。


### 利用扰动函数的解决思路
1. hashcode

2. 高低位混合后（更具随机性）再取模

```
h                   10001100 00011000 00001100 00000110
h >>> 16            00000000 00000000 10001100 00011000        高16位变低16位，高位补0

h ^ (h >>> 16)      10001100 00011000 10000000 00011110        高位hashcode值不变，低位是：混合原哈希码高低位，使hash值更具有随机性。


hash & (length - 1)  
                    10001100 00011000 10000000 00011110        低位更具随机性的hash码
                &   00000000 00000000 00000000 00001111        数组长度-1
                ---------------------------------------
                    00000000 00000000 00000000 00001110        =>14（ 数组tab[14] ）
```


### HashMap的数组长度为什么是2的n次方
因为(2^n - 1)用二进制表示之后是低位都是1，高位都是0。如：（16-1=15）00000000 00000000 00000000 00001111。
这样在与hash值取模的时候就忽略高位，只剩hash值低位部分作为数组下标。
